# 开启注册 - 开发规范

本文档约定 Web 端「开启注册」功能的流程、数据来源、配置与落库规则，不涉及具体代码实现细节。

---

## 1. 功能目标

- 从**邮箱管理**中选取**未注册**的邮箱，按配置的线程数、接码 API、代理执行批量注册。
- 执行完成后：完成 GPT 注册、激活 Sora，并将结果写入**账号管理**；若注册成功，邮箱管理侧该邮箱展示为**已注册**。
- **无人值守**：通过定时任务 + 心跳检测，实现「开启即提交任务、按未注册数量自动跑满」，无需人工持续操作。

---

## 2. 任务模型与总数量

### 2.1 任务模型

- **提交即任务**：用户点击「开启注册」即提交一次注册任务（或开启任务调度）。
- **单任务**：每条未注册邮箱对应一条注册任务；任务队列由当前未注册邮箱列表动态决定。

### 2.2 总注册数量

- **由邮箱管理中的未注册数量决定**：总任务数 = 当前 `emails` 表中、且该 `email` 在 `accounts` 表中**不存在**的记录数。
- 不在此次「开启」时人为指定数量；未注册邮箱被消费（注册成功写入 accounts）后，剩余未注册数减少，后续轮次或定时拉取时自动以最新未注册数为准。

---

## 3. 数据来源

### 3.1 待注册邮箱

- **来源表**：`emails`（邮箱管理）。
- **筛选条件**：当前邮箱地址在 `accounts` 表中**不存在**的记录，即「未注册」邮箱。
- **使用方式**：按需取 N 条未注册邮箱（N 受线程数、队列调度约束），每条包含：`id, email, password, uuid, token`（用于拉信/接码等）。

---

## 4. 定时任务与心跳检测

### 4.1 定时任务

- **开启注册时启动定时任务**：用户点击「开启注册」后，除可立即消费当前未注册队列外，应启动调度（如定时轮询或任务队列）。
- **调度策略**：按配置的**线程数**并发取未注册邮箱执行注册；一轮结束后可根据「是否还有未注册邮箱」决定下一轮时间间隔或持续拉取，实现无人值守。

### 4.2 心跳检测

- **目的**：在无人值守场景下，可检测注册进程/服务是否存活、是否卡死。
- **约定**：运行中的注册任务或调度器应定期上报心跳（如写入 `system_settings` 的某字段或独立心跳表、或通过现有 `run_logs` 时间戳推断）；前端或监控可据此判断「最近一次活动时间」，超时则视为异常并提示或告警。
- 具体心跳间隔、存储位置与告警策略在实现时确定。

---

## 5. 读取的配置

以下配置均来自**系统设置**（`system_settings`），开启注册前应校验必要项已填写：

| 配置项 | 说明 | 用途 |
|--------|------|------|
| 线程数 `thread_count` | 并发执行注册的任务数 | 控制同时跑几条注册流程 |
| 重试次数 `retry_count` | 单条注册失败后的重试次数 | 取值范围 **1～5**，在「运行参数」中配置 |
| 手机号接码 API | `sms_api_url`、`sms_api_key`、`sms_openai_service`、`sms_max_price` 等 | 获取手机号、收验证码（若注册流程需要） |
| 邮箱 API | `email_api_url`、`email_api_key`（Hotmail007） | 邮箱已在 emails 表，此处可用于拉信读验证码等（若流程需要） |
| 代理 IP | `proxy_url` 或 `proxy_api_url` | 注册请求走代理 |
| 打码 API | `captcha_api_url`、`captcha_api_key`（2Captcha） | 若流程中有 hCaptcha 等需打码 |

- **运行参数**：线程数、重试次数等放在「运行参数」卡片中；**运行参数一行显示 2 个输入框**（如：线程数 | 重试次数 一行，每卡使用次数 | 手机号可绑定次数 一行），便于布局统一。
- 单条任务失败时，最多重试 `retry_count` 次（1～5），超过后记为失败并写入日志/统计。

具体哪些步骤用邮箱 API、哪些用接码 API、哪些用打码，由**注册流程实现**决定；本规范只约定「从系统设置读取上述配置并在执行注册时使用」。

---

## 6. 注册流程（执行逻辑）

- 流程以现有**协议注册**实现为准（如 `protocol_register` 中的逻辑）：
  1. **GPT 注册**：完成 OAuth/注册步骤，拿到 `code` 并换取 `access_token` / `refresh_token`。
  2. **激活 Sora**：用上述 token 调用 Sora 侧接口完成激活（如设置 username 等）。
- 单条任务输入：一条未注册邮箱（email + password + 其他邮箱表字段）、以及本次任务使用的代理、接码/打码/拉信等配置。
- 多线程：按配置的**线程数**并发执行多条注册任务，注意共享资源（如接码余额、代理池）的线程安全与限流。
- **失败重试**：单条注册失败时，根据系统设置中的**重试次数**（1～5）进行重试；超过重试次数后记为失败，写入日志并更新统计。

---

## 7. 结果落库与展示

### 7.1 写入账号表 `accounts`

每条注册任务结束后，无论成功失败，建议在**账号管理**有记录可查；成功时至少写入：

- `email`：邮箱
- `password`：密码
- `refresh_token`：从回调换得的 RT
- `status`：状态文案（如 `Registered`、`Registered+Sora`、或失败原因简述）
- `registered_at`：注册完成时间（可选）
- `has_sora`：是否已激活 Sora（0/1）
- `has_plus`：是否开通 Plus（0/1）
- `phone_bound`：是否绑定手机（0/1）
- `proxy`：使用的代理（可选）

具体字段名以当前 `accounts` 表结构为准；若有「仅成功才写入」的策略，需在规范或实现中说明。

### 7.2 账号列表展示

账号管理列表需能展示：

- 是否**注册成功**（可由 `status` 或是否写入 RT 等推导）
- 是否开通 **Sora**（`has_sora`）
- 是否开通 **Plus**（`has_plus`）
- 是否**绑定手机**（`phone_bound`）

当前表结构已包含上述字段，前端按字段展示即可。

### 7.3 邮箱管理「已注册」状态

- 邮箱管理中的**状态**列「已注册/未注册」由**是否在 `accounts` 表中存在该 email** 推导（现有逻辑已支持）。
- 因此：**注册成功并写入 `accounts` 后，无需额外接口更新邮箱表**；刷新邮箱列表即可看到对应邮箱变为「已注册」。

---

## 8. 运行日志与统计

- 每次「开启注册」运行过程，建议写入 `run_logs`（或现有日志表），便于在**批量注册**页查看最近运行记录。
- 成功/失败数量可写入 `system_settings`（如 `last_run_success`、`last_run_fail`），供仪表盘展示；具体字段名与现有实现保持一致。

---

## 9. 小结（检查清单）

实现「开启注册」时，需满足：

1. **任务与数量**：提交即任务；总注册数量由邮箱管理中**未注册数量**决定，不在此次操作中人为指定。
2. **数据来源**：从 `emails` 表取「未注册」邮箱（不在 `accounts` 中的 email）。
3. **定时与心跳**：开启注册时启动定时任务；运行中具备心跳检测，支持无人值守与异常发现。
4. **配置**：从 `system_settings` 读取线程数、**重试次数（1～5）**、手机号接码 API、邮箱 API、代理、打码 API 等，并在执行前做必要校验；**运行参数**卡片内一行显示 2 个输入框（含重试次数）。
5. **流程**：按现有协议注册逻辑执行 GPT 注册 + Sora 激活；多线程按线程数并发；单条失败按重试次数（1～5）重试，超过后记为失败。
6. **落库**：结果写入 `accounts`（email、password、refresh_token、status、has_sora、has_plus、phone_bound 等）。
7. **展示**：账号列表展示注册成功、Sora、Plus、绑定手机；邮箱管理侧「已注册」由 accounts 存在性推导，无需单独更新邮箱表。
8. **日志**：运行记录与成功/失败数写入现有日志与统计机制。

以上为开发规范，具体接口与实现细节在编码阶段再定。
